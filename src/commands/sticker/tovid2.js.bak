import { createRequire } from 'module';
const require = createRequire(import.meta.url);
var axios = require("axios");
import fetch from 'node-fetch';
import { FormData, Blob } from 'formdata-node';
import { JSDOM } from 'jsdom';
import config from '../../src/data/setting.js'
import { existsSync, readFileSync, readdirSync, statSync, watchFile, writeFileSync, promises, unlinkSync, createReadStream } from 'fs';
import {
    fileURLToPath,
    pathToFileURL
} from 'url'
import { randomBytes } from 'crypto'
import { exec, spawn } from 'child_process'
import { join } from 'path';

export const aliases = ['tovid', 'tovd', 'tovideo']
export const category = 'Sticker'
export const group = true
export const owner = true
export async function execute(m, client, { prefix, cmd }) {

    if (!m.quoted) return m.reply(`Balas stiker/audio yang ingin diubah menjadi video dengan perintah ${prefix + cmd}`)
    let mime = m.quoted.mimetype || ''
    if (!/webp|audio/.test(mime)) return m.reply(`Balas stiker/audio yang ingin diubah menjadi video dengan perintah ${prefix + cmd}`)
    let media = await m.quoted.download()
    if (/webp/.test(mime)) {
        let out = await webp2mp4(media)
        await client.sendMessage(m.chat, { video: { url: out.result }, mimetype: 'video/mp4', filename: 'cvvid.mp4' }, { quoted: m })

    } else if (/audio/.test(mime)) {
        let out = await ffmpeg(media, [
            '-filter_complex', 'color',
            '-pix_fmt', 'yuv420p',
            '-crf', '51',
            '-c:a', 'copy',
            '-shortest'
        ], 'mp3', 'mp4')
        await client.sendMessage(m.chat, { video: { url: out }, mimetype: 'video/mp4', filename: 'cvvid.mp4' }, { quoted: m })

    }
    //await client.sendFilek(m.chat, out, 'out.mp4', '*DONE*', m, 0, { thumbnail: out })
    // await client.sendFileFromUrl(m.chat, out, "ok", m, '', 'mp4')
}



function webp2mp4(path) {
    return new Promise((resolve, reject) => {
        const form = new BodyForm()
        form.append('new-image-url', '')
        form.append('new-image', createReadStream(path))
        axios({
            method: 'post',
            url: 'https://s6.ezgif.com/webp-to-mp4',
            data: form,
            headers: {
                'Content-Type': `multipart/form-data; boundary=${form._boundary}`
            }
        }).then(({ data }) => {
            const bodyFormThen = new BodyForm()
            const $ = cheerio.load(data)
            const file = $('input[name="file"]').attr('value')
            bodyFormThen.append('file', file)
            bodyFormThen.append('convert', "Convert WebP to MP4!")
            axios({
                method: 'post',
                url: 'https://ezgif.com/webp-to-mp4/' + file,
                data: bodyFormThen,
                headers: {
                    'Content-Type': `multipart/form-data; boundary=${bodyFormThen._boundary}`
                }
            }).then(({ data }) => {
                const $ = cheerio.load(data)
                const result = 'https:' + $('div#output > p.outfile > video > source').attr('src')
                resolve({
                    status: true,
                    result: result
                })
            }).catch(reject)
        }).catch(reject)
    })
}

function ffmpeg(buffer, args = [], ext = '', ext2 = '') {
    return new Promise(async (resolve, reject) => {
        try {
            let tmp = join(process.cwd(), '/src/temp/vid/', + new Date + '.' + ext)
            let out = tmp + '.' + ext2
            await promises.writeFile(tmp, buffer)
            spawn('ffmpeg', [
                '-y',
                '-i', tmp,
                ...args,
                out
            ])
                .on('error', reject)
                .on('close', async (code) => {
                    try {
                        await promises.unlink(tmp)
                        if (code !== 0) return reject(code)
                        resolve({
                            data: await promises.readFile(out),
                            filename: out,
                            delete() {
                                return promises.unlink(out)
                            }
                        })
                    } catch (e) {
                        reject(e)
                    }
                })
        } catch (e) {
            reject(e)
        }
    })
}